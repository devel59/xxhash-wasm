{"version":3,"file":"hasher.js","sources":["../src/hasher.js"],"sourcesContent":["const u32_BYTES = 4;\nconst u64_BYTES = 8;\n\n// The xxh32 hash state struct:\nconst XXH32_STATE_SIZE_BYTES =\n  u32_BYTES + // total_len\n  u32_BYTES + // large_len\n  u32_BYTES * 4 + // Accumulator lanes\n  u32_BYTES * 4 + // Internal buffer\n  u32_BYTES + // memsize\n  u32_BYTES; // reserved\n\n// The xxh64 hash state struct:\nconst XXH64_STATE_SIZE_BYTES =\n  u64_BYTES + // total_len\n  u64_BYTES * 4 + // Accumulator lanes\n  u64_BYTES * 4 + // Internal buffer\n  u32_BYTES + // memsize\n  u32_BYTES + // reserved32\n  u64_BYTES; // reserved64\n\nexport function createHasher(wasmExports) {\n  const {\n    mem,\n    xxh32,\n    xxh64,\n    init32,\n    update32,\n    digest32,\n    init64,\n    update64,\n    digest64,\n  } = wasmExports;\n\n  let memory = new Uint8Array(mem.buffer);\n  // Grow the wasm linear memory to accommodate length + offset bytes\n  function growMemory(length, offset) {\n    if (mem.buffer.byteLength < length + offset) {\n      const extraPages = Math.ceil(\n        // Wasm pages are spec'd to 64K\n        (length + offset - mem.buffer.byteLength) / (64 * 1024)\n      );\n      mem.grow(extraPages);\n      // After growing, the original memory's ArrayBuffer is detached, so we'll\n      // need to replace our view over it with a new one over the new backing\n      // ArrayBuffer.\n      memory = new Uint8Array(mem.buffer);\n    }\n  }\n\n  // The h32 and h64 streaming hash APIs are identical, so we can implement\n  // them both by way of a templated call to this generalized function.\n  function create(size, seed, init, update, digest, finalize) {\n    // Ensure that we've actually got enough space in the wasm memory to store\n    // the state blob for this hasher.\n    growMemory(size);\n\n    // We'll hold our hashing state in this closure.\n    const state = new Uint8Array(size);\n    memory.set(state);\n    init(0, seed);\n\n    // Each time we interact with wasm, it may have mutated our state so we'll\n    // need to read it back into our closed copy.\n    state.set(memory.subarray(0, size));\n\n    return {\n      update(input) {\n        memory.set(state);\n        let length;\n        if (typeof input === \"string\") {\n          growMemory(input.length * 3, size);\n          length = encoder.encodeInto(input, memory.subarray(size)).written;\n        } else {\n          // The only other valid input type is a Uint8Array\n          growMemory(input.byteLength, size);\n          memory.set(input, size);\n          length = input.byteLength;\n        }\n        update(0, size, length);\n        state.set(memory.subarray(0, size));\n        return this;\n      },\n      digest() {\n        memory.set(state);\n        return finalize(digest(0));\n      },\n    };\n  }\n\n  // Logical shift right makes it an u32, otherwise it's interpreted as an i32.\n  function forceUnsigned32(i) {\n    return i >>> 0;\n  }\n\n  // BigInts are arbitrary precision and signed, so to get the \"correct\" u64\n  // value from the return, we'll need to force that interpretation.\n  const u64Max = 2n ** 64n - 1n;\n  function forceUnsigned64(i) {\n    return i & u64Max;\n  }\n\n  function pass(i) {\n    return i;\n  }\n\n  const encoder = new TextEncoder();\n  const defaultSeed = 0;\n  const defaultBigSeed = 0n;\n\n  function h32Signed(str, seed = defaultSeed) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/encodeInto#buffer_sizing\n    // By sizing the buffer to 3 * string-length we guarantee that the buffer\n    // will be appropriately sized for the utf-8 encoding of the string.\n    growMemory(str.length * 3, 0);\n    return xxh32(0, encoder.encodeInto(str, memory).written, seed);\n  }\n\n  function h32Unsigned(str, seed) {\n    return forceUnsigned32(h32Signed(str, seed));\n  }\n\n  function h64Signed(str, seed = defaultBigSeed) {\n    growMemory(str.length * 3, 0);\n    return xxh64(0, encoder.encodeInto(str, memory).written, seed);\n  }\n\n  function h64Unsigned(str, seed) {\n    return forceUnsigned64(h64Signed(str, seed));\n  }\n\n  function h32RawSigned(inputBuffer, seed = defaultSeed) {\n    growMemory(inputBuffer.byteLength, 0);\n    memory.set(inputBuffer);\n    return xxh32(0, inputBuffer.byteLength, seed);\n  }\n\n  function h64RawSigned(inputBuffer, seed = defaultBigSeed) {\n    growMemory(inputBuffer.byteLength, 0);\n    memory.set(inputBuffer);\n    return xxh64(0, inputBuffer.byteLength, seed);\n  }\n\n  function create32(finalize, seed = defaultSeed) {\n    return create(\n      XXH32_STATE_SIZE_BYTES,\n      seed,\n      init32,\n      update32,\n      digest32,\n      finalize\n    );\n  }\n\n  function create64(finalize, seed = defaultBigSeed) {\n    return create(\n      XXH64_STATE_SIZE_BYTES,\n      seed,\n      init64,\n      update64,\n      digest64,\n      finalize\n    );\n  }\n\n  return {\n    h32: h32Unsigned,\n    h32ToString(str, seed) {\n      return h32Unsigned(str, seed).toString(16).padStart(8, \"0\");\n    },\n    h32Raw(inputBuffer, seed) {\n      return forceUnsigned32(h32RawSigned(inputBuffer, seed));\n    },\n    create32(seed) {\n      return create32(forceUnsigned32, seed);\n    },\n    h64: h64Unsigned,\n    h64ToString(str, seed) {\n      return h64Unsigned(str, seed).toString(16).padStart(16, \"0\");\n    },\n    h64Raw(inputBuffer, seed) {\n      return forceUnsigned64(h64RawSigned(inputBuffer, seed));\n    },\n    create64(seed) {\n      return create64(forceUnsigned64, seed);\n    },\n    signed: {\n      h32: h32Signed,\n      h32Raw: h32RawSigned,\n      create32(seed) {\n        return create32(pass, seed);\n      },\n      h64: h64Signed,\n      h64Raw: h64RawSigned,\n      create64(seed) {\n        return create64(pass, seed);\n      },\n    },\n  };\n}\n"],"names":["createHasher","wasmExports","mem","xxh32","xxh64","init32","update32","digest32","init64","update64","digest64","memory","Uint8Array","buffer","growMemory","length","offset","byteLength","extraPages","Math","ceil","grow","create","size","seed","init","update","digest","finalize","state","set","subarray","input","encoder","encodeInto","written","this","forceUnsigned32","i","u64Max","forceUnsigned64","pass","TextEncoder","defaultSeed","defaultBigSeed","h32Signed","str","h32Unsigned","h64Signed","h64Unsigned","h32RawSigned","inputBuffer","h64RawSigned","create32","u32_BYTES","create64","u64_BYTES","h32","h32ToString","toString","padStart","h32Raw","h64","h64ToString","h64Raw","signed"],"mappings":"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"}